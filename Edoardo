/*

    QUESTA PARTE COMMENTATA E' CIO' CHE E' RIMASTO DEL VECCHIO CODICE, E' ANCORA DA SISTEMARE
    FA DI NUOVO SEGMENTATION FAULT E IL PROBLEMA STA NELL'ULTIMO CICLO (VEDI COMMENTO SOTTO)

    int temp1, temp2;

    for (int k = 0; k < endpoints; ++k) {
        for (int i = 0; i < videos; ++i) {
            fscanf(input, "%d %d %d", &temp1, &temp2, &request_videos[temp2][temp1]);
        }
    }

    for(i=0; i<caches; i++) for(ii=0; ii<videos; ii++)
    {
        priority[i][ii] = 0;
        for(iii=0; iii<endpoints; iii++)
        {
            if(latency_to_cache[iii] > 0) priority[i][ii] += request_videos[iii][ii] * (latency[iii] - latency_to_cache[iii][i]) / (latency[iii] - 1.0);
        }
    }

    fclose(input);

}
*/


//  MODIFICHE A CASO SUL CODICE CHE HO TROVATO DI Là; SGRAMMATICATEZZA, CASINO, COMMMENTI IN GIRO E EGOCENTRISMO RANDOM
//      SE BOH CI CAPITE QUALCOSA NEL PERCHè NON VA ALLA RIGA 146 CHE PROPRIO

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int videos, endpoints, requests, caches, dimension;

int main(int argc, char *argv[])
{


    // CONTROLLO ARGOMENTI E APERTURA FILE

    if(argc != 2)
    {
        printf("Wrong number of arguments");
        exit(1);
    }
    printf("Opening file...\n");

    FILE *input = fopen(argv[1], "r");

    if(input == NULL)
    {
        printf("Failed opening file");
        exit(2);
    }
    printf("File opened correctly\n");

    // DICHIARAZIONE VARIABILI

    int i[3] = {};

    // DICHIARAZIONE ARRAY                                                                              #  ID           #  VALUE

    //int sizes[videos];                                                                                  // video        size video
    int *sizes;
    sizes = (int *)malloc(videos*sizeof(int));
    //int latency[endpoints];                                                                          // endpoint     latenza verso datacenter
    int *latency;
    latency = (int *)malloc(endpoints*sizeof(int));
    //int number_of_caches[endpoints];
    int *number_of_caches;
    number_of_caches = (int *)malloc(endpoints*sizeof(int));
                                                                       // endpoint     numero di caches connesse



    fscanf(input, "%d %d %d %d %d\n", &videos, &endpoints, &requests, &caches, &dimension);

    // DICHIARAZIONE MATRICI                                                                            #  ID_1         #  ID_2         #  VALUE

    int **latency_to_cache = (int**)malloc(endpoints*sizeof(int*));                                      // endpoint     cache           latenza verso cache
    for(i[0]=0; i[0]<endpoints; i[0]++) latency_to_cache[i[0]]=(int*)malloc(caches*sizeof(int));        // 0 if NULL (no connection)

    int **request_videos = (int**)malloc(endpoints*sizeof(int*));                                        // endpoint     videos          numero di richieste
    for(i[0]=0; i[0]<endpoints; i[0]++) request_videos[i[0]]=(int*)malloc(videos*sizeof(int));          // 0 if NULL (no requests)

    double **priority = (double**)malloc(caches*sizeof(double*));                                        // cache        videos          priority
    for(i[0]=0; i[0]<caches; i[0]++) priority[i[0]]=(double*)malloc(videos*sizeof(double));             // 0 if NULL (no requests)

    // VIDEO SIZES
//ex test
//    printf("%d\n", sizes[95]);
//    printf("%d\n", sizes[96]);
//    printf("%d\n", sizes[97]);
//    printf("%d\n", sizes[98]);
//    printf("%d\n", sizes[99]);

char row[100*3 + 100];

fgets(row, 400, input);

char *ptr;
ptr = row;
//lettura valori by gnone
for(i[0]=0; i[0]<videos; i[0]++){
    sscanf(ptr, "%d ", &sizes[i[0]]);
    printf("%d\n", sizes[i[0]]);

    ptr = strchr(ptr,' ') + 1;


}



/* lettura dei valori secondo marco, non funziona con 100 valori...
    for(i[0]=0; i[0]<videos; i[0]++)
    {
        fscanf(input, "%d", &sizes[i[0]]);
        printf("%d\n", sizes[i[0]]);
    }
*/

//prima cosa per debug
   // for(i[0]=0; i[0]<videos; i[0]++)printf("%d \n", sizes[i[0]]);

    // CACHE CONNECTIONS initialization

    for(i[0]=0; i[0]<endpoints; i[0]++) for(i[1]=0; i[1]<caches; i[1]++) latency_to_cache[i[0]][i[1]] = 0;

    // LATENCIES

    char row1[30];
    /*  LATENCIES READING BY MARCO, in the end the values are notchanged from ^up^ init

    for(i[0]=0;  i[0]<endpoints; i[0]++)
    {
        fscanf(input, "%d %d", &latency[i[0]], &number_of_caches[i[0]]);
        int tmp_cache;
        for(i[1]=0; i[1]<number_of_caches[i[0]]; i[1]++) fscanf(input, "%d %d\n", &tmp_cache, &latency_to_cache[i[0]][tmp_cache]);
    }*/

    //BELLISSIMO : HO MESSO LE TRE GETS A CASO PER VEDERE CHE SUCCEDEVA : LA PRIMA PRENDE IL NULLA, LA SECONDA PRENDE CORRETTAMENTE LA RIGA SOTTO QUELLA CHE DVREBBE PRENDERE, E LìALTRA IDEM
    for(i[0]=0;  i[0]<endpoints; i[0]++)
    {
        fgets(row1, 30, input);
        fgets(row1, 30, input);
        fgets(row1, 30, input);
        sscanf(row1, "%d %d", &latency[i[0]], &number_of_caches[i[0]]);
        int tmp_cache;
        for(i[1]=0; i[1]<number_of_caches[i[0]]; i[1]++) {
                fscanf(input, "%d %d\n", &tmp_cache, &latency_to_cache[i[0]][tmp_cache]);
                }

    }



//CHECK LATENCIES <-gnone

    for(i[0]=0;  i[0]<endpoints; i[0]++)
    {
        for(i[1]=0; i[1]<caches; i[1]++) printf("%d ", latency_to_cache[i[0]][i[1]]);
        printf("\n");
    }
    // VIDEO REQUESTS
    // CI DEVE ESSERE QUALCOSA DI SBAGLIATO QUA. SI CERA IL EOF
    // IL WHILE E' CORRETTO? MEGLIO UN FOR?NO VAB NEE. QUEL EOF VA BENE?NO NULL. FORSE LA SEGMENTAZIONE E' DOVUTA AL PUNTATORE (input) ENORME
    //<------------- fino a qui gnone ha controllato, NON è VERO SOPRA NON FUNZIONA
    int tmp_video;
    int tmp_endpoint;
    int tmp_request;
    while(!feof(input))
    {
        fscanf(input, "%d %d %d\n", &tmp_video, &tmp_endpoint, &tmp_request);
        request_videos[tmp_endpoint][tmp_video] = tmp_request;
    }

    // CHIUSURA

    fclose(input);
    return 0;
}




/*

ME AT THE ZOO .IN 

100 10 100 10 100
20 11 50 26 5 3 6 32 40 22 4 20 50 27 49 44 1 37 35 27 14 33 6 22 23 48 44 14 26 9 46 44 15 32 31 8 39 27 39 27 1 17 1 47 44 42 16 3 44 48 5 25 4 39 39 7 24 28 14 44 22 11 27 37 11 16 50 33 22 26 7 12 17 30 12 12 4 32 12 46 43 4 12 34 11 7 47 29 24 40 41 10 5 22 22 24 37 34 50 5
1013 3
0 170
1 22
2 224
696 2
0 7
1 50
1114 3
1 202
4 175
5 2
464 2
1 24
8 25
522 5
3 216
5 155
6 139
7 208
8 145
321 4
0 26
2 70
8 159
9 92
1288 2
2 163
9 153
226 1
7 86
316 5
4 236
5 79
6 9
7 53
8 67
365 5
2 225
3 62
5 141
6 147
9 66
27 4 340
13 8 249
1 1 449
24 4 279
0 2 924
8 4 862
1 5 51
0 9 837
30 9 927
0 8 167
3 4 214
0 4 59
2 3 986
7 2 785
0 4 424
16 9 996
8 5 719
89 1 297
0 9 580
19 5 748
31 0 585
2 5 853
0 1 961
8 0 186
5 5 676
81 2 120
3 8 247
16 5 620
0 4 584
8 5 935
32 2 717
8 2 396
8 6 300
34 3 752
13 0 459
4 9 997
7 0 214
13 2 934
21 8 880
0 3 158
0 8 704
1 6 988
62 6 8
1 8 300
16 6 939
7 1 116
5 1 554
17 2 605
7 7 204
0 6 264
2 4 906
16 8 93
0 4 277
99 0 772
23 6 262
1 7 552
26 4 10
1 0 884
2 9 546
0 8 583
10 1 128
3 3 899
2 7 861
1 8 211
3 2 103
74 7 885
54 4 621
0 1 930
0 8 977
30 8 882
15 0 737
0 3 931
0 8 865
44 8 267
65 7 109
4 8 859
0 2 817
0 4 306
1 7 228
26 0 194
0 3 865
10 9 280
0 6 400
5 9 537
1 9 116
2 9 179
4 9 266
46 1 435
5 7 314
4 6 512
6 3 577
10 2 709
65 0 926
82 5 720
54 7 671
16 3 70
43 6 331
10 3 849
11 7 301
1 3 409
*/
