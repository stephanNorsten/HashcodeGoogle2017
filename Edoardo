/*

    QUESTA PARTE COMMENTATA E' CIO' CHE E' RIMASTO DEL VECCHIO CODICE, E' ANCORA DA SISTEMARE
    FA DI NUOVO SEGMENTATION FAULT E IL PROBLEMA STA NELL'ULTIMO CICLO (VEDI COMMENTO SOTTO)

    int temp1, temp2;

    for (int k = 0; k < endpoints; ++k) {
        for (int i = 0; i < videos; ++i) {
            fscanf(input, "%d %d %d", &temp1, &temp2, &request_videos[temp2][temp1]);
        }
    }

    for(i=0; i<caches; i++) for(ii=0; ii<videos; ii++)
    {
        priority[i][ii] = 0;
        for(iii=0; iii<endpoints; iii++)
        {
            if(latency_to_cache[iii] > 0) priority[i][ii] += request_videos[iii][ii] * (latency[iii] - latency_to_cache[iii][i]) / (latency[iii] - 1.0);
        }
    }

    fclose(input);

}
*/


//   SGRAMMATICATEZZA, CASINO, COMMMENTI IN GIRO E EGOCENTRISMO RANDOM
//      SE BOH CI CAPITE QUALCOSA NEL PERCHè NON VA ALLA RIGA 146 CHE PROPRIO

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int videos, endpoints, requests, caches, dimension;

int main(int argc, char *argv[])
{
    // CONTROLLO ARGOMENTI E APERTURA FILE

    if(argc != 2)
    {
        printf("Wrong number of arguments");
        exit(1);
    }
    printf("Opening file...\n");

    FILE *input = fopen(argv[1], "r");

    if(input == NULL)
    {
        printf("Failed opening file");
        exit(2);
    }
    printf("File opened correctly\n");

    // DICHIARAZIONE VARIABILI

    int i[3] = {};

    //LETTURA PRIMA RIGA

    fscanf(input, "%d %d %d %d %d\n", &videos, &endpoints, &requests, &caches, &dimension);


    // DICHIARAZIONE ARRAY     le dichiarazioni commentate sono quelle secondo Marco,                                                                         #  ID           #  VALUE

    //int sizes[videos];                                                             // video        size video
    int *sizes;
    sizes = (int *)malloc(videos*sizeof(int));
    //int latency[endpoints];                                                        // endpoint     latenza verso datacenter
    int *latency;
    latency = (int *)malloc(endpoints*sizeof(int));
    //int number_of_caches[endpoints];                                               // endpoint     numero di caches connesse
    int *number_of_caches;
    number_of_caches = (int *)malloc(endpoints*sizeof(int));

    // DICHIARAZIONE MATRICI   mancava un asterisco in giro                                             #  ID_1         #  ID_2         #  VALUE

    int **latency_to_cache = (int**)malloc(endpoints*sizeof(int*));                                     // endpoint     cache           latenza verso cache
    for(i[0]=0; i[0]<endpoints; i[0]++) latency_to_cache[i[0]]=(int*)malloc(caches*sizeof(int));        // 0 if NULL (no connection)

    int **request_videos = (int**)malloc(endpoints*sizeof(int*));                                       // endpoint     videos          numero di richieste
    for(i[0]=0; i[0]<endpoints; i[0]++) request_videos[i[0]]=(int*)malloc(videos*sizeof(int));          // 0 if NULL (no requests)

    double **priority = (double**)malloc(caches*sizeof(double*));                                       // cache        videos          priority
    for(i[0]=0; i[0]<caches; i[0]++) priority[i[0]]=(double*)malloc(videos*sizeof(double));             // 0 if NULL (no requests)



    // VIDEO SIZES

    //Former test, la lettura sotto commentata era bacata sugli ultimi 5 valori da me (gnone)
    //    printf("%d\n", sizes[95]);
    //    printf("%d\n", sizes[96]);
    //    printf("%d\n", sizes[97]);
    //    printf("%d\n", sizes[98]);
    //    printf("%d\n", sizes[99]);

    char row[100*3 + 100];

    fgets(row, 400, input);

    char *ptr;   //copio la riga in un più agile puntatore
    ptr = row;
                 //poi leggo i valori e sposto il puntatore dopo lo spazio successivo (scarto il primo valore già letto)
    for(i[0]=0; i[0]<videos; i[0]++)
        {

        sscanf(ptr, "%d ", &sizes[i[0]]);
        printf("%d\n", sizes[i[0]]);

        ptr = strchr(ptr,' ') + 1;

        }



    /* lettura dei valori secondo marco,ma non funziona con 100 valori...
    for(i[0]=0; i[0]<videos; i[0]++)
    {
        fscanf(input, "%d", &sizes[i[0]]);
        printf("%d\n", sizes[i[0]]);
    }
    */

    //prima cosa per debug
    // for(i[0]=0; i[0]<videos; i[0]++)printf("%d \n", sizes[i[0]]);

    // CACHE CONNECTIONS initialization

    for(i[0]=0; i[0]<endpoints; i[0]++) for(i[1]=0; i[1]<caches; i[1]++) latency_to_cache[i[0]][i[1]] = 0;

    // LATENCIES

    char row1[30];

    /*  LATENCIES READING BY MARCO, ma alla fine non modifica i valori nella matrice

    for(i[0]=0;  i[0]<endpoints; i[0]++)
    {
        fscanf(input, "%d %d", &latency[i[0]], &number_of_caches[i[0]]);
        int tmp_cache;
        for(i[1]=0; i[1]<number_of_caches[i[0]]; i[1]++) fscanf(input, "%d %d\n", &tmp_cache, &latency_to_cache[i[0]][tmp_cache]);
    }*/

    ////BELLISSIMO : HO MESSO LE TRE GETS A CASO PER VEDERE CHE SUCCEDEVA : LA PRIMA PRENDE IL NULLA, LA SECONDA PRENDE CORRETTAMENTE LA RIGA SOTTO QUELLA CHE DVREBBE PRENDERE, E LìALTRA IDEM
    for(i[0]=0;  i[0]<endpoints; i[0]++)
    {
        fgets(row1, 30, input);
        sscanf(row1, "%d %d", &latency[i[0]], &number_of_caches[i[0]]);
        int tmp_cache;
        for(i[1]=0; i[1]<number_of_caches[i[0]]; i[1]++) {
                fscanf(input, "%d %d",&tmp_cache, (*(latency_to_cache+i[0]))+tmp_cache);
                }

    }



    //per il debug : CHECK LATENCIES

    for(i[0]=0;  i[0]<endpoints; i[0]++)
    {
        for(i[1]=0; i[1]<caches; i[1]++) printf("%d ", latency_to_cache[i[0]][i[1]]);
        printf("\n");
    }

    // VIDEO REQUESTS
    // CONTINUA A NON FUNZIONARE TUTTO...

    int tmp_video;
    int tmp_endpoint;
    int tmp_request;
    while(!feof(input))
    {
        fscanf(input, "%d %d %d\n", &tmp_video, &tmp_endpoint, &tmp_request);
        request_videos[tmp_endpoint][tmp_video] = tmp_request;
    }

    // CHIUSURA

    fclose(input);
    return 0;
}

